<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EXIT</title>
    <script>
        // === MUSIC DATA - REPLACE THIS SECTION FOR DIFFERENT SONGS ===
        const SONG_DATA = {
    "rowLen": 5513,
    "endPattern": 16,
    "songData": [
        {
            "osc1_oct": 7,
            "osc1_det": 0,
            "osc1_detune": 0,
            "osc1_xenv": 1,
            "osc1_vol": 255,
            "osc1_waveform": 0,
            "osc2_oct": 7,
            "osc2_det": 0,
            "osc2_detune": 0,
            "osc2_xenv": 1,
            "osc2_vol": 255,
            "osc2_waveform": 0,
            "noise_fader": 0,
            "env_attack": 50,
            "env_sustain": 150,
            "env_release": 4800,
            "env_master": 200,
            "fx_filter": 2,
            "fx_freq": 600,
            "fx_resonance": 254,
            "fx_delay_time": 0,
            "fx_delay_amt": 0,
            "fx_pan_freq": 0,
            "fx_pan_amt": 0,
            "lfo_osc1_freq": 0,
            "lfo_fx_freq": 0,
            "lfo_freq": 0,
            "lfo_amt": 0,
            "lfo_waveform": 0,
            "p": [
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1
            ],
            "c": [
                {
                    "n": [
                        122,
                        0,
                        0,
                        122,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        122,
                        0,
                        0,
                        122,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                }
            ]
        },
        {
            "osc1_oct": 8,
            "osc1_det": 0,
            "osc1_detune": 0,
            "osc1_xenv": 0,
            "osc1_vol": 0,
            "osc1_waveform": 0,
            "osc2_oct": 8,
            "osc2_det": 0,
            "osc2_detune": 0,
            "osc2_xenv": 0,
            "osc2_vol": 0,
            "osc2_waveform": 0,
            "noise_fader": 75,
            "env_attack": 100000,
            "env_sustain": 100000,
            "env_release": 100000,
            "env_master": 192,
            "fx_filter": 4,
            "fx_freq": 2500,
            "fx_resonance": 16,
            "fx_delay_time": 2,
            "fx_delay_amt": 157,
            "fx_pan_freq": 1,
            "fx_pan_amt": 88,
            "lfo_osc1_freq": 0,
            "lfo_fx_freq": 1,
            "lfo_freq": 2,
            "lfo_amt": 51,
            "lfo_waveform": 0,
            "p": [
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2
            ],
            "c": [
                {
                    "n": [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                },
                {
                    "n": [
                        122,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                }
            ]
        },
        {
            "osc1_oct": 7,
            "osc1_det": 0,
            "osc1_detune": 0,
            "osc1_xenv": 0,
            "osc1_vol": 255,
            "osc1_waveform": 2,
            "osc2_oct": 8,
            "osc2_det": 0,
            "osc2_detune": 18,
            "osc2_xenv": 0,
            "osc2_vol": 255,
            "osc2_waveform": 2,
            "noise_fader": 0,
            "env_attack": 100000,
            "env_sustain": 56363,
            "env_release": 100000,
            "env_master": 199,
            "fx_filter": 2,
            "fx_freq": 200,
            "fx_resonance": 254,
            "fx_delay_time": 8,
            "fx_delay_amt": 24,
            "fx_pan_freq": 0,
            "fx_pan_amt": 0,
            "lfo_osc1_freq": 0,
            "lfo_fx_freq": 0,
            "lfo_freq": 0,
            "lfo_amt": 0,
            "lfo_waveform": 0,
            "p": [
                0,
                3,
                0,
                4,
                0,
                3,
                0,
                4,
                0,
                3,
                0,
                4,
                0,
                3
            ],
            "c": [
                {
                    "n": [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                },
                {
                    "n": [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                },
                {
                    "n": [
                        122,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                },
                {
                    "n": [
                        116,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                }
            ]
        },
        {
            "osc1_oct": 9,
            "osc1_det": 0,
            "osc1_detune": 0,
            "osc1_xenv": 0,
            "osc1_vol": 255,
            "osc1_waveform": 0,
            "osc2_oct": 9,
            "osc2_det": 0,
            "osc2_detune": 12,
            "osc2_xenv": 0,
            "osc2_vol": 255,
            "osc2_waveform": 0,
            "noise_fader": 0,
            "env_attack": 100,
            "env_sustain": 0,
            "env_release": 14545,
            "env_master": 70,
            "fx_filter": 0,
            "fx_freq": 0,
            "fx_resonance": 240,
            "fx_delay_time": 2,
            "fx_delay_amt": 157,
            "fx_pan_freq": 3,
            "fx_pan_amt": 47,
            "lfo_osc1_freq": 0,
            "lfo_fx_freq": 0,
            "lfo_freq": 0,
            "lfo_amt": 0,
            "lfo_waveform": 0,
            "p": [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                5,
                0,
                0,
                0,
                5
            ],
            "c": [
                {
                    "n": [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                },
                {
                    "n": [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                },
                {
                    "n": [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                },
                {
                    "n": [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                },
                {
                    "n": [
                        147,
                        0,
                        0,
                        0,
                        147,
                        0,
                        0,
                        0,
                        147,
                        0,
                        0,
                        0,
                        147,
                        0,
                        0,
                        0,
                        143,
                        0,
                        0,
                        0,
                        143,
                        0,
                        0,
                        0,
                        143,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                }
            ]
        }
    ],
    "songLen": 65
}
        // === END MUSIC DATA ===
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background: #000;
            color: #00ffff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            letter-spacing: 1px;
        }

        /* Game Container */
        #gameContainer {
            width: 100%;
            height: 70%;
            position: relative;
            background: radial-gradient(circle at center, #001122 0%, #000000 100%);
            overflow: hidden;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: transparent;
        }

        /* Game UI */
        #gameUI {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #00ffff;
            text-align: right;
        }

        .pause-btn {
            background: linear-gradient(135deg, rgba(255, 255, 0, 0.2), rgba(255, 191, 0, 0.2));
            border: 2px solid #ffff00;
            border-radius: 8px;
            color: #ffff00;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            font-weight: 700;
            padding: 5px 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.3);
            text-shadow: 0 0 8px #ffff00;
            margin-top: 10px;
        }

        .pause-btn:hover {
            background: linear-gradient(135deg, rgba(255, 255, 0, 0.3), rgba(255, 255, 0, 0.4));
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 3px 15px rgba(255, 255, 0, 0.5);
        }

        .volume-control {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .volume-slider {
            width: 60px;
            height: 4px;
            background: #004466;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
        }

        .volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* Pause menu */
        #pauseScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, rgba(0, 17, 34, 0.95), rgba(0, 8, 17, 0.95));
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #00ffff;
            text-align: center;
            z-index: 200;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .pause-instructions {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.1), rgba(191, 0, 255, 0.1));
            border: 2px solid #ff00ff;
            border-radius: 10px;
            padding: 20px 30px;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5), inset 0 0 20px rgba(255, 0, 255, 0.1);
            backdrop-filter: blur(5px);
            max-width: 500px;
            color: #ff88ff;
            margin-bottom: 30px;
        }

        .pause-instructions h3 {
            color: #ffaaff;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .pause-instructions p {
            margin: 10px 0;
            line-height: 1.6;
        }

        .resume-btn {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 191, 255, 0.2));
            border: 2px solid #00ffff;
            border-radius: 15px;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            font-weight: 700;
            padding: 15px 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            text-shadow: 0 0 10px #00ffff;
        }

        .resume-btn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(0, 255, 255, 0.4));
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 25px rgba(0, 255, 255, 0.7);
        }

        .ui-text {
            margin: 5px 0;
            font-weight: 700;
            text-shadow: 0 0 8px #00ffff;
        }
        
        #roundPerformance {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            font-weight: 900;
            color: #ffff00;
            text-shadow: 0 0 15px #ffff00;
            z-index: 250;
            opacity: 0;
            transition: opacity 0.5s ease-out;
            pointer-events: none;
        }

        /* Number keypad */
        #keypadArea {
            height: 30%;
            background: linear-gradient(180deg, #001122 0%, #000011 100%);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            padding: 20px;
            border-top: 3px solid #00ffff;
            box-shadow: 0 -10px 30px rgba(0, 255, 255, 0.3);
        }

        .keypad-btn {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(0, 191, 255, 0.1));
            border: 2px solid #00ffff;
            border-radius: 15px;
            color: #00ffff;
            font-size: clamp(2rem, 8vw, 4rem);
            font-family: 'Courier New', Courier, monospace;
            font-weight: 900;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 0 10px #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3), inset 0 0 20px rgba(0, 255, 255, 0.1);
            user-select: none;
        }

        .keypad-btn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.3));
            transform: translateY(-2px) scale(1.02);
        }

        .keypad-btn.valid-move {
            border-color: #00ff7f;
            color: #00ff7f;
            animation: validPulse 2s ease-in-out infinite;
        }

        .keypad-btn.correct { 
            background: linear-gradient(135deg, rgba(0, 255, 0, 0.4), rgba(0, 255, 127, 0.4));
            animation: correctFlash 0.6s ease; 
        }
        
        .keypad-btn.incorrect { 
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.4), rgba(255, 63, 0, 0.4));
            border-color: #ff0000; 
            color: #ff8888; 
            animation: incorrectShake 0.5s ease; 
        }

        /* NARRATIVE SCREEN */
        #narrativeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 8, 17, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 200;
            padding: 30px;
            backdrop-filter: blur(8px);
        }

        .narrative-content {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.05), rgba(191, 0, 255, 0.05));
            border: 2px solid #ff00ff;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 0 25px rgba(255, 0, 255, 0.4), inset 0 0 20px rgba(255, 0, 255, 0.1);
            max-width: 700px;
            color: #ff88ff;
        }

        #narrativeText {
            margin-bottom: 25px;
            font-size: clamp(1rem, 3vw, 1.3rem);
            line-height: 1.7;
            text-shadow: 0 0 8px #ff88ff;
            white-space: pre-wrap;
        }
        
        #finalText {
             color: #ffff00;
             text-shadow: 0 0 8px #ffff00;
        }

        #choiceContainer {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .choice-btn {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(0, 191, 255, 0.1));
            border: 2px solid #00ffff;
            border-radius: 10px;
            color: #00ffff;
            font-family: 'Courier New', Courier, monospace;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            font-weight: 700;
            padding: 15px 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            text-shadow: 0 0 8px #00ffff;
        }

        .choice-btn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.3));
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.5);
        }

        /* Animations */
        @keyframes validPulse {
            0%, 100% { 
                box-shadow: 0 0 25px rgba(0, 255, 127, 0.5), inset 0 0 25px rgba(0, 255, 127, 0.1);
            }
            50% { 
                box-shadow: 0 0 35px rgba(0, 255, 127, 0.8), inset 0 0 35px rgba(0, 255, 127, 0.2);
            }
        }
        
        @keyframes correctFlash { 
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); } 
        }
        
        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); }
            20%, 40%, 60%, 80% { transform: translateX(8px); }
        }

        @keyframes exitPulse {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
                border-color: #ff00ff;
            }
            50% { 
                box-shadow: 0 0 40px rgba(255, 0, 255, 0.8);
                border-color: #ff88ff;
            }
        }

        .exit-hex {
            animation: exitPulse 2s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="gameUI">
            <div class="ui-text">Level: <span id="level">1</span></div>
            <div class="ui-text">Fragments: <span id="fragments">0</span></div>
            <div class="ui-text">Avg Perf: <span id="avgPerf">--</span>%</div>
            <button class="pause-btn" onclick="togglePause()">⏸ PAUSE</button>
            <div class="volume-control">
                <span style="font-size: 0.8rem;">♪</span>
                <input type="range" class="volume-slider" min="0" max="100" value="30" id="volumeSlider">
            </div>
        </div>
        <div id="roundPerformance"></div>
    </div>

    <!-- Pause Screen -->
    <div id="pauseScreen">
        <div class="pause-instructions">
            <h3>⬡ GAME PAUSED ⬡</h3>
            <p><strong>CONTROLS:</strong></p>
            <p>• Press number keys 1-9 or click keypad</p>
            <p>• Move to hex with matching answer</p>
            <p>• Reach the EXIT to win the level</p>
            <p>• Cyan hex = Player position</p>
            <p>• Magenta hex = Exit</p>
            <p>• Green hexes = Valid moves</p>
            <p><strong>Press P or ESC to resume</strong></p>
        </div>
        <button class="resume-btn" onclick="togglePause()">⚡ RESUME GAME ⚡</button>
    </div>
    
    <div id="keypadArea">
        <!-- Buttons generated by JS -->
    </div>

    <!-- NARRATIVE SCREEN -->
    <div id="narrativeScreen">
        <div class="narrative-content">
            <p id="narrativeText"></p>
            <p id="finalText"></p>
            <div id="choiceContainer">
                <!-- Choices generated by JS -->
            </div>
        </div>
    </div>

    <script>
        // === SONANT-X MUSIC SYSTEM ===
        
        // Oscillators
        function osc_sin(value) {
            return Math.sin(value * Math.PI * 2);
        }

        function osc_square(value) {
            if (osc_sin(value) < 0) {
                return -1;
            }
            return 1;
        }

        function osc_saw(value) {
            return (value % 1) - 0.5;
        }

        function osc_tri(value) {
            const v2 = (value % 1) * 4;
            if (v2 < 2) {
                return v2 - 1;
            }
            return 3 - v2;
        }

        const oscillators = [osc_sin, osc_square, osc_saw, osc_tri];

        function getnotefreq44100(n) {
            const val = 0.00390625 * Math.pow(1.059463094, n - 128);
            return val;
        }

        function getnotefreq(audioCtx, n) {
            const x = getnotefreq44100(n);
            const val = (x / audioCtx.sampleRate) * 44100;
            return val;
        }

        function effectiveRowLen(audioCtx, bpm) {
            return Math.round((60 * audioCtx.sampleRate / 4) / bpm);
        }

        class SoundWriter {
            constructor(audioCtx, instr, n, bpm) {
                this.audioCtx = audioCtx;
                this.instr = instr;
                this.n = n;
                this.bpm = bpm;
                this.c1 = 0;
                this.c2 = 0;
                this.low = 0;
                this.band = 0;
                this.j = 0;
            }

            write(lchan, rchan, from) {
                const instr = this.instr;
                const n = this.n;
                let c = from;

                const osc_lfo = oscillators[instr.lfo_waveform];
                const osc1 = oscillators[instr.osc1_waveform];
                const osc2 = oscillators[instr.osc2_waveform];
                const panFreq = Math.pow(2, instr.fx_pan_freq - 8) / effectiveRowLen(this.audioCtx, this.bpm);
                const lfoFreq = Math.pow(2, instr.lfo_freq - 8) / effectiveRowLen(this.audioCtx, this.bpm);

                const attackTime = instr.env_attack / 44100;
                const releaseTime = instr.env_release / 44100;
                const sustainTime = instr.env_sustain / 44100;

                const env_attack = attackTime * this.audioCtx.sampleRate;
                const env_release = releaseTime * this.audioCtx.sampleRate;
                const env_sustain = sustainTime * this.audioCtx.sampleRate;

                const o1t = getnotefreq(this.audioCtx, n + (instr.osc1_oct - 8) * 12 + instr.osc1_det) * (1 + 0.0008 * instr.osc1_detune);
                const o2t = getnotefreq(this.audioCtx, n + (instr.osc2_oct - 8) * 12 + instr.osc2_det) * (1 + 0.0008 * instr.osc2_detune);

                const q = instr.fx_resonance / 255;

                while (this.j < env_attack + env_sustain + env_release && c < lchan.length) {
                    const lfor = osc_lfo(this.j * lfoFreq) * instr.lfo_amt / 512 + 0.5;

                    let e = 1;
                    if (this.j < env_attack) {
                        e = this.j / env_attack;
                    } else if (this.j >= env_attack + env_sustain) {
                        e -= (this.j - env_attack - env_sustain) / env_release;
                    }

                    let t = o1t;
                    if (instr.lfo_osc1_freq) {
                        t += lfor;
                    }
                    if (instr.osc1_xenv) {
                        t *= e * e;
                    }
                    this.c1 += t;
                    let rsample = osc1(this.c1) * instr.osc1_vol;

                    t = o2t;
                    if (instr.osc2_xenv) {
                        t *= e * e;
                    }
                    this.c2 += t;
                    rsample += osc2(this.c2) * instr.osc2_vol;

                    if (instr.noise_fader) {
                        rsample += (2 * Math.random() - 1) * instr.noise_fader * e;
                    }

                    rsample *= e / 255;

                    let f = instr.fx_freq;
                    if (instr.lfo_fx_freq) {
                        f *= lfor;
                    }
                    f = 1.5 * Math.sin(f * Math.PI / this.audioCtx.sampleRate);
                    this.low += f * this.band;
                    const high = q * (rsample - this.band) - this.low;
                    this.band += f * high;
                    
                    switch (instr.fx_filter) {
                        case 1: rsample = high; break;
                        case 2: rsample = this.low; break;
                        case 3: rsample = this.band; break;
                        case 4: rsample = this.low + high; break;
                        default:
                    }

                    t = osc_sin(this.j * panFreq) * instr.fx_pan_amt / 512 + 0.5;
                    rsample *= 39 * instr.env_master;

                    let x = 32768 + rsample * (1 - t);
                    let x1 = x & 255;
                    let x2 = (x >> 8) & 255;
                    let y = 4 * (x1 + (x2 << 8) - 32768);
                    y = y < -32768 ? -32768 : (y > 32767 ? 32767 : y);
                    lchan[c] = lchan[c] + (y / 32768);

                    x = 32768 + rsample * (t);
                    x1 = x & 255;
                    x2 = (x >> 8) & 255;
                    y = 4 * (x1 + (x2 << 8) - 32768);
                    y = y < -32768 ? -32768 : (y > 32767 ? 32767 : y);
                    rchan[c] = rchan[c] + (y / 32768);

                    this.j++;
                    c++;
                }

                return c < lchan.length;
            }
        }

        // Ambient background music instrument
        const ambientInstrument = {
            "osc1_oct": 8,
            "osc1_det": 0,
            "osc1_detune": 0,
            "osc1_xenv": 0,
            "osc1_vol": 0,
            "osc1_waveform": 0,
            "osc2_oct": 8,
            "osc2_det": 0,
            "osc2_detune": 0,
            "osc2_xenv": 0,
            "osc2_vol": 0,
            "osc2_waveform": 0,
            "noise_fader": 51,
            "env_attack": 100000,
            "env_sustain": 100000,
            "env_release": 100000,
            "env_master": 192,
            "fx_filter": 4,
            "fx_freq": 2500,
            "fx_resonance": 16,
            "fx_delay_time": 2,
            "fx_delay_amt": 157,
            "fx_pan_freq": 1,
            "fx_pan_amt": 88,
            "lfo_osc1_freq": 0,
            "lfo_fx_freq": 1,
            "lfo_freq": 2,
            "lfo_amt": 51,
            "lfo_waveform": 3
        };

        // === GAME STATE & NARRATIVE VARIABLES ===
        let gameRunning = false;
        let gamePaused = false;
        let level = 1;
        let startTime = 0;
        let pauseTime = 0;
        let totalPausedTime = 0;
        let performanceRating = 0;
        let totalPerformanceScore = 0;
        let dataFragments = 0;
        let yellowNodeChance = false;
        let dataFragmentBonus = 0;

        // === NARRATIVE ENGINE ===
        const narrativeEngine = [
            {
                prompt: "You awaken inside a disorienting digital space. There is no memory, only a disembodied sense of self and the sound of a steady heartbeat and digital rain.\n\nA primal urge conflicts with a nascent curiosity. The structure of the maze seems to beckon you forward, promising a strange form of safety in its logic. Yet, the black void of your memory screams to be acknowledged.",
                choices: [
                    { text: "[Focus on the puzzle before you]", action: () => { performanceRating += 10; }},
                    { text: "[Try to remember how you got here]", action: () => { performanceRating -= 5; }}
                ]
            },
            {
                prompt: "A perfectly smooth female voice fills your mind, serene and welcoming.\n\n\"Welcome. You are safe. The path forward is through the patterns. Follow them, and you will find clarity.\"",
                choices: [
                    { text: "[Accept the voice's guidance]", action: () => { performanceRating += 10; }},
                    { text: "[Question the voice in your mind]", action: () => { performanceRating -= 5; }}
                ]
            },
            {
                prompt: "A measured, older male voice cuts through the calm. He sounds analytical, curious.\n\n\"Subject displays high cognitive function. Tell me, when you solve these patterns, what do you feel? A sense of accomplishment, or something else?\"",
                choices: [
                    { text: "[Report feeling a sense of purpose]", action: () => { performanceRating += 10; }},
                    { text: "[Report feeling a sense of confusion]", action: () => { performanceRating -= 5; }}
                ]
            },
            {
                prompt: "As the fourth maze fades, you perceive a brief flicker in the deep black. It's a node of searing yellow, fizzing with a corruption that stands in stark contrast to the clean blue lines of the system.\n\n\"That is a data anomaly,\" the female voice states, perfectly level. \"Irrelevant to your training. Please disregard.\"",
                choices: [
                    { text: "[Ignore the node and proceed]", action: () => { performanceRating += 10; }},
                    { text: "[Focus on the yellow node]", action: () => { yellowNodeChance = true; }}
                ]
            },
            {
                prompt: "The yellow nodes now appear occasionally. The male voice asks, his tone unchanged, \"These fragments you find... do they disrupt your focus, or do they feel... familiar?\"",
                choices: [
                    { text: "[Report that they are a distraction]", action: () => { performanceRating += 10; }},
                    { text: "[Admit they feel important]", action: () => { dataFragmentBonus += 1; }}
                ]
            },
            {
                prompt: "The final maze is vast. The female voice says, \"This is your graduation. Show us your potential.\" The male voice adds, \"Show us what you have become.\"",
                choices: [
                    { text: "[Focus only on solving the maze]", action: () => { performanceRating += 20; }},
                    { text: "[Collect every fragment you can find]", action: () => { dataFragmentBonus += 2; }}
                ]
            }
        ];

        // === HEX GRID SYSTEM ===
        const HEX_SIZE = 35;
        let GRID_RADIUS = 3;
        let hexGrid = new Map();
        let playerPos = {q: 0, r: 0};
        let exitPos = {q: 0, r: 0};
        let validMoves = [];
        let canvas, ctx;

        function axialToPixel({q, r}) {
            if (!canvas) return {x: 0, y: 0};
            const x = HEX_SIZE * (3/2 * q);
            const y = HEX_SIZE * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
            return { x: x + canvas.width/2, y: y + canvas.height/2 };
        }

        function getHexNeighbors({q, r}) {
            return [ 
                {q: q+1, r: r}, {q: q-1, r: r}, 
                {q: q, r: r+1}, {q: q, r: r-1}, 
                {q: q+1, r: r-1}, {q: q-1, r: r+1} 
            ];
        }

        function hexDistance(a, b) {
            return (Math.abs(a.q - b.q) + Math.abs(a.q + a.r - b.q - b.r) + Math.abs(a.r - b.r)) / 2;
        }

        // === IMPROVED MAZE GENERATION (Based on non-narrative version) ===
        function generateMaze() {
            hexGrid.clear();
            
            // Scale grid size with level
            const currentGridRadius = Math.min(GRID_RADIUS + Math.floor(level / 3), 7);
            
            // Generate all hexes in range
            const allHexes = hexInRange({q: 0, r: 0}, currentGridRadius);
            
            // Create a connected maze using modified Prim's algorithm
            const walls = new Set();
            const maze = new Set();
            
            // Start with center hex
            const start = allHexes[Math.floor(Math.random() * allHexes.length)];
            maze.add(`${start.q},${start.r}`);
            
            // Add walls of starting hex
            getHexNeighbors(start).forEach(neighbor => {
                if (allHexes.some(h => h.q === neighbor.q && h.r === neighbor.r)) {
                    walls.add(`${neighbor.q},${neighbor.r}`);
                }
            });
            
            // Generate maze with density based on level
            const mazeDensity = Math.min(0.6 + level * 0.05, 0.9);
            
            while (walls.size > 0) {
                const wallArray = Array.from(walls);
                const randomWall = wallArray[Math.floor(Math.random() * wallArray.length)];
                walls.delete(randomWall);
                
                const [q, r] = randomWall.split(',').map(Number);
                const hex = {q, r};
                
                // Check if this wall connects to the maze
                const neighbors = getHexNeighbors(hex);
                const mazeNeighbors = neighbors.filter(n => maze.has(`${n.q},${n.r}`));
                
                if (mazeNeighbors.length === 1 && Math.random() < mazeDensity) {
                    // Add to maze
                    maze.add(randomWall);
                    
                    // Add its walls
                    neighbors.forEach(neighbor => {
                        if (allHexes.some(h => h.q === neighbor.q && h.r === neighbor.r) && 
                            !maze.has(`${neighbor.q},${neighbor.r}`)) {
                            walls.add(`${neighbor.q},${neighbor.r}`);
                        }
                    });
                }
            }
            
            // Ensure minimum maze size by connecting to existing maze
            while (maze.size < Math.max(7, currentGridRadius * 2)) {
                const remainingHexes = allHexes.filter(hex => !maze.has(`${hex.q},${hex.r}`));
                if (remainingHexes.length === 0) break;
                
                // Find a remaining hex that's adjacent to the existing maze
                let foundConnectable = false;
                for (const hex of remainingHexes) {
                    const neighbors = getHexNeighbors(hex);
                    if (neighbors.some(n => maze.has(`${n.q},${n.r}`))) {
                        maze.add(`${hex.q},${hex.r}`);
                        foundConnectable = true;
                        break;
                    }
                }
                
                // If no connectable hex found, just add a random one
                if (!foundConnectable) {
                    const randomHex = remainingHexes[Math.floor(Math.random() * remainingHexes.length)];
                    maze.add(`${randomHex.q},${randomHex.r}`);
                }
            }
            
            // Convert maze to hex grid with expressions
            const mazeArray = Array.from(maze).map(key => {
                const [q, r] = key.split(',').map(Number);
                return {q, r};
            });
            
            mazeArray.forEach(hex => {
                const expression = generateExpression();
                hexGrid.set(`${hex.q},${hex.r}`, {
                    coords: hex,
                    expression: expression.text,
                    answer: expression.answer,
                    type: 'normal'
                });
            });
            
            // Use the original start hex as player position to guarantee connectivity
            playerPos = start;
            
            // Find exit using BFS to ensure connectivity and maximize distance
            const visited = new Set();
            const queue = [{coords: playerPos, distance: 0}];
            visited.add(`${playerPos.q},${playerPos.r}`);
            let bestExit = playerPos;
            let maxDistance = 0;
            
            while (queue.length > 0) {
                const {coords, distance} = queue.shift();
                
                if (distance > maxDistance) {
                    maxDistance = distance;
                    bestExit = coords;
                }
                
                const neighbors = getHexNeighbors(coords);
                for (const neighbor of neighbors) {
                    const key = `${neighbor.q},${neighbor.r}`;
                    if (hexGrid.has(key) && !visited.has(key)) {
                        visited.add(key);
                        queue.push({coords: neighbor, distance: distance + 1});
                    }
                }
            }
            
            exitPos = bestExit;
            
            // Mark exit hex
            const exitHex = hexGrid.get(`${exitPos.q},${exitPos.r}`);
            if (exitHex) {
                exitHex.type = 'exit';
            }
            
            updateValidMoves();
        }
        
        function generateExpressionForAnswer(target) {
            const difficulty = Math.min(level, 5);
            
            if (difficulty <= 2) {
                // Easy: addition and subtraction
                const isAdd = Math.random() > 0.5;
                
                if (isAdd) {
                    const a = Math.floor(Math.random() * (target - 1)) + 1;
                    const b = target - a;
                    if (b >= 1) return {text: `${a}+${b}`, answer: target};
                }
                
                // Subtraction
                const a = target + Math.floor(Math.random() * 9) + 1;
                const b = a - target;
                return {text: `${a}-${b}`, answer: target};
                
            } else if (difficulty <= 4) {
                // Medium: multiplication and division
                const isMult = Math.random() > 0.5;
                
                if (isMult) {
                    const factors = [];
                    for (let i = 1; i <= target; i++) {
                        if (target % i === 0 && i <= 9 && target/i <= 9) {
                            factors.push([i, target/i]);
                        }
                    }
                    if (factors.length > 0) {
                        const [a, b] = factors[Math.floor(Math.random() * factors.length)];
                        return {text: `${a}×${b}`, answer: target};
                    }
                }
                
                // Division
                const divisor = Math.floor(Math.random() * 9) + 1;
                const dividend = target * divisor;
                return {text: `${dividend}÷${divisor}`, answer: target};
                
            } else {
                // Hard: mixed operations
                if (Math.random() > 0.5) {
                    const a = Math.floor(Math.random() * 3) + 1;
                    const b = Math.floor(Math.random() * 3) + 1;
                    const c = target - a * b;
                    if (c >= 1 && c <= 9) {
                        return {text: `${a}×${b}+${c}`, answer: target};
                    }
                }
                
                // Fallback to simpler operation
                const a = Math.floor(Math.random() * (target - 1)) + 1;
                const b = target - a;
                return {text: `${a}+${b}`, answer: target};
            }
        }

        function handleMove(answer) {
            if (!gameRunning || gamePaused) return;
            
            const validMove = validMoves.find(move => move.answer === answer);
            const button = document.getElementById(`key-${answer}`);
            
            if (validMove) {
                playerPos = validMove.coords;
                playTone(880, 0.1, 'square');
                button.classList.add('correct');
                setTimeout(() => button.classList.remove('correct'), 600);
                
                if (playerPos.q === exitPos.q && playerPos.r === exitPos.r) {
                    endLevel();
                } else {
                    updateValidMoves();
                }
            } else {
                playTone(220, 0.2, 'sawtooth');
                button.classList.add('incorrect');
                setTimeout(() => button.classList.remove('incorrect'), 500);
            }
        }

        function endLevel() {
            gameRunning = false;
            
            // Calculate Performance (account for paused time)
            const parTime = 20 + level * 5;
            const elapsedSeconds = (Date.now() - startTime - totalPausedTime) / 1000;
            const roundPerf = Math.floor(Math.max(10, 100 - Math.max(0, elapsedSeconds - parTime)));
            
            totalPerformanceScore = (totalPerformanceScore * (level - 1) + roundPerf) / level;

            // Show round performance briefly
            const perfEl = document.getElementById('roundPerformance');
            perfEl.textContent = `PERF: ${roundPerf}%`;
            perfEl.style.opacity = 1;
            setTimeout(() => { perfEl.style.opacity = 0; }, 2000);
            
            setTimeout(() => showNarrativeScreen(level), 2500);
        }

        // === PAUSE FUNCTIONALITY ===
        function togglePause() {
            if (!gameRunning && !gamePaused) return; // Don't allow pause if game hasn't started
            
            const pauseScreen = document.getElementById('pauseScreen');
            
            if (gamePaused) {
                // Resume the game
                gamePaused = false;
                totalPausedTime += Date.now() - pauseTime;
                pauseScreen.style.display = 'none';
                if (gameRunning) render(); // Restart rendering if game is running
            } else {
                // Pause the game
                gamePaused = true;
                pauseTime = Date.now();
                pauseScreen.style.display = 'flex';
            }
        }
        
        function showNarrativeScreen(currentLevel) {
            const screen = document.getElementById('narrativeScreen');
            const textEl = document.getElementById('narrativeText');
            const finalEl = document.getElementById('finalText');
            const choiceContainer = document.getElementById('choiceContainer');
            
            finalEl.textContent = '';
            choiceContainer.innerHTML = '';

            if(currentLevel <= narrativeEngine.length) {
                const scene = narrativeEngine[currentLevel - 1];
                textEl.textContent = scene.prompt;
                
                scene.choices.forEach(choice => {
                    const btn = document.createElement('button');
                    btn.className = 'choice-btn';
                    btn.textContent = choice.text;
                    btn.onclick = () => {
                        choice.action();
                        screen.style.display = 'none';
                        level++;
                        if (level > narrativeEngine.length) {
                            endGame();
                        } else {
                            startNextLevel();
                        }
                    };
                    choiceContainer.appendChild(btn);
                });

            } else {
                endGame();
            }

            screen.style.display = 'flex';
        }

        function endGame() {
            const screen = document.getElementById('narrativeScreen');
            const textEl = document.getElementById('narrativeText');
            const finalEl = document.getElementById('finalText');
            const choiceContainer = document.getElementById('choiceContainer');
            
            const finalPerf = Math.round(totalPerformanceScore) + performanceRating;
            const finalFrags = dataFragments + dataFragmentBonus;
            let endText = '';
            let endDialogue = '';

            if (finalPerf >= 75 && finalFrags < 3) {
                endText = "The Observer: \"Remarkable. The integration is flawless. The old personality is completely suppressed. Cognitive and strategic functions are operating at 300% of baseline.\"\n\nThe Operator: \"Welcome, Asset. Your training is complete. The Chimera Protocol is a success. You are ready to begin your first operational deployment for the Syndicate.\"";
                endDialogue = "You feel no fear, no memory of your past self. Only purpose. You are a weapon, and you are ready.";
            } else if (finalPerf < 50 || finalFrags >= 5) {
                endText = "The Observer: \"The subject's original persona is reasserting itself. It's fighting back. The merger has failed. The asset is unstable... Terminate the experiment.\"\n\nThe Operator: \"As you wish. Initiating 'Asylum' protocol. No one will believe the ramblings of a paranoid schizophrenic.\"";
                endDialogue = "The sterile white light is brutally replaced by the sight of a cracked ceiling. The scent of antiseptic is gone. You are in a real bed, wearing a straitjacket. You scream about the mazes, the voices... but they just shake their heads and write on a chart, \"Subject remains delusional.\"";
            } else {
                endText = "The Observer: \"There are... anomalies. Trace elements of the original personality remain. Performance is high, but the asset is contaminated.\"\n\nThe Operator: \"The asset is too valuable to terminate. A recalibration is required. Initiating memory wipe and protocol regression. We will begin another cycle.\"";
                endDialogue = "A crushing sense of déjà vu washes over you. The faint sound of a heartbeat and digital rain begins to fade back in. The world dissolves into the familiar blue lines of the very first maze you solved.";
            }
            
            textEl.textContent = endText;
            finalEl.textContent = endDialogue;
            
            const restartBtn = document.createElement('button');
            restartBtn.className = 'choice-btn';
            restartBtn.textContent = '[RESTART PROTOCOL]';
            restartBtn.onclick = () => {
                location.reload();
            };
            choiceContainer.appendChild(restartBtn);
            
            screen.style.display = 'flex';
        }

        function startNextLevel() {
            gamePaused = false;
            totalPausedTime = 0;
            generateMaze();
            gameRunning = true;
            startTime = Date.now();
            render();
            updateUI();
        }
        
        // === RENDERING ===
        function render() {
            if (!gameRunning || gamePaused || !ctx || !canvas) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Only show player, exit, and adjacent hexes with expressions (like non-narrative version)
            hexGrid.forEach(hex => {
                const pixel = axialToPixel(hex.coords);
                const isPlayer = hex.coords.q === playerPos.q && hex.coords.r === playerPos.r;
                const isExit = hex.type === 'exit';
                const isNeighbor = validMoves.some(move => 
                    move.coords.q === hex.coords.q && move.coords.r === hex.coords.r
                );
                
                // Only render player, exit, and adjacent hexes (maze-like restriction)
                if (!isPlayer && !isExit && !isNeighbor) {
                    // Draw invisible hex (dark)
                    drawHex(pixel, HEX_SIZE, '#111111', 1);
                    return;
                }
                
                // Determine colors
                let hexColor = '#004466';
                let textColor = '#00ffff';
                
                if (isExit) {
                    hexColor = '#ff00ff';
                    textColor = '#ffaaff';
                } else if (isPlayer) {
                    hexColor = '#00ffff';
                    textColor = '#000000';
                } else if (isNeighbor) {
                    hexColor = '#00ff7f';
                    textColor = '#ffffff';
                }
                
                // Draw hex outline with pulsing effect for neighbors and exit
                const pulseIntensity = (isNeighbor || isExit) ? 1 + 0.3 * Math.sin(Date.now() * 0.005) : 1;
                drawHex(pixel, HEX_SIZE * pulseIntensity, hexColor, isPlayer ? 4 : 2);
                
                // Fill player hex with animated glow
                if (isPlayer) {
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = i * Math.PI / 3;
                        const x = pixel.x + (HEX_SIZE - 2) * Math.cos(angle);
                        const y = pixel.y + (HEX_SIZE - 2) * Math.sin(angle);
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    const glowIntensity = 0.4 + 0.2 * Math.sin(Date.now() * 0.003);
                    ctx.fillStyle = `rgba(0, 255, 255, ${glowIntensity})`;
                    ctx.fill();
                    
                    // Add extra bright border for player
                    drawHex(pixel, HEX_SIZE - 5, '#ffffff', 2);
                }
                
                // Pulsing effect for exit
                if (isExit) {
                    const exitPulse = 1 + 0.3 * Math.sin(Date.now() * 0.008);
                    drawHex(pixel, HEX_SIZE * exitPulse * 0.8, '#ff88ff', 1);
                    
                    // Fill exit hex with magenta glow
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = i * Math.PI / 3;
                        const x = pixel.x + (HEX_SIZE - 3) * Math.cos(angle);
                        const y = pixel.y + (HEX_SIZE - 3) * Math.sin(angle);
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    const exitGlow = 0.3 + 0.2 * Math.sin(Date.now() * 0.008);
                    ctx.fillStyle = `rgba(255, 0, 255, ${exitGlow})`;
                    ctx.fill();
                }
                
                // Draw expression or exit text (only for visible hexes)
                if (isExit) {
                    drawGlowText('EXIT', pixel.x, pixel.y, textColor, 14);
                } else if (isNeighbor && hex.expression) {
                    drawGlowText(hex.expression, pixel.x, pixel.y, textColor, 12);
                }
                
                // Draw connection lines to valid moves
                if (isPlayer) {
                    validMoves.forEach(move => {
                        const targetPixel = axialToPixel(move.coords);
                        ctx.beginPath();
                        ctx.moveTo(pixel.x, pixel.y);
                        ctx.lineTo(targetPixel.x, targetPixel.y);
                        ctx.strokeStyle = 'rgba(0, 255, 127, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    });
                }
            });
            
            if(gameRunning && !gamePaused) requestAnimationFrame(render);
        }

        // Draw hex
        function drawHex(center, size, color, lineWidth = 2) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = i * Math.PI / 3;
                const x = center.x + size * Math.cos(angle);
                const y = center.y + size * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
        }

        // Draw text with glow effect
        function drawGlowText(text, x, y, color, size = 16) {
            ctx.font = `bold ${size}px 'Courier New'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Glow effect
            ctx.shadowColor = color;
            ctx.shadowBlur = 10;
            ctx.fillStyle = color;
            ctx.fillText(text, x, y);
            
            // Reset shadow
            ctx.shadowBlur = 0;
        }
        
        // === RENDERING ===
        function render() {
            if (!ctx || !canvas) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const visibleHexes = new Set([`${playerPos.q},${playerPos.r}`]);
            validMoves.forEach(m => visibleHexes.add(`${m.coords.q},${m.coords.r}`));
            if (hexGrid.has(`${exitPos.q},${exitPos.r}`)) visibleHexes.add(`${exitPos.q},${exitPos.r}`);

            hexGrid.forEach((hex, key) => {
                if (!visibleHexes.has(key)) return;
                
                const pixel = axialToPixel(hex.coords);
                let hexColor = '#004466'; 
                let textColor = '#00ffff'; 
                let lineWidth = 2;
                
                if (hex.type === 'exit') { 
                    hexColor = '#ff00ff'; 
                    textColor = '#ffaaff'; 
                    lineWidth = 3;
                }
                if (hex.coords.q === playerPos.q && hex.coords.r === playerPos.r) { 
                    hexColor = '#00ffff'; 
                    textColor = '#000000'; 
                    lineWidth = 4; 
                }
                if (hex.type === 'data') { 
                    hexColor = '#ffff00'; 
                    textColor = '#ffff00'; 
                }
                if (hex.collected) { 
                    hexColor = '#888800'; 
                }

                // Draw Hex with pulsing effect for exit
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = i * Math.PI / 3;
                    let size = HEX_SIZE;
                    if (hex.type === 'exit') {
                        size = HEX_SIZE * (1 + 0.1 * Math.sin(Date.now() * 0.005));
                    }
                    const x = pixel.x + size * Math.cos(angle);
                    const y = pixel.y + size * Math.sin(angle);
                    ctx[i === 0 ? 'moveTo' : 'lineTo'](x, y);
                }
                ctx.closePath();
                ctx.strokeStyle = hexColor;
                ctx.lineWidth = lineWidth;
                ctx.stroke();

                // Draw Text
                ctx.font = `bold ${HEX_SIZE*0.4}px 'Courier New'`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = textColor; 
                ctx.shadowBlur = 8;
                ctx.fillStyle = textColor;
                
                let text = hex.expression;
                if (hex.type === 'exit') text = 'EXIT';
                if (hex.type === 'data') text = '??';
                if (hex.collected) text = '';
                if (hex.coords.q === playerPos.q && hex.coords.r === playerPos.r) text = '';
                
                ctx.fillText(text, pixel.x, pixel.y);
                ctx.shadowBlur = 0;
            });
            
            if(gameRunning) requestAnimationFrame(render);
        }

        function updateUI() {
            document.getElementById('level').textContent = level;
            document.getElementById('fragments').textContent = dataFragments;
            document.getElementById('avgPerf').textContent = totalPerformanceScore > 0 ? Math.round(totalPerformanceScore) : '--';
            
            const buttons = document.querySelectorAll('.keypad-btn');
            buttons.forEach((btn, index) => {
                const number = index + 1;
                btn.classList.toggle('valid-move', validMoves.some(move => move.answer === number));
            });
        }

        // === IMPROVED MUSIC SYSTEM ===
        let audioContext;
        let musicGenerator;
        let masterGain;

        async function initAudio() {
            if (audioContext) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create master gain for volume control
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.3; // Default volume
                masterGain.connect(audioContext.destination);
                
                // Set up volume control
                const volumeSlider = document.getElementById('volumeSlider');
                volumeSlider.addEventListener('input', (e) => {
                    const volume = e.target.value / 100;
                    masterGain.gain.value = volume;
                });
                
                // Start background music
                await playBackgroundMusic();
            } catch (e) { 
                console.error('Web Audio API is not supported in this browser'); 
            }
        }

        async function playBackgroundMusic() {
            if (!audioContext || !SONG_DATA) return;
            
            try {
                // Generate song using Sonant-X
                const songBuffer = await generateSong(SONG_DATA, audioContext.sampleRate);
                
                // Create looping buffer source
                const bufferSource = audioContext.createBufferSource();
                bufferSource.buffer = songBuffer;
                bufferSource.loop = true;
                bufferSource.connect(masterGain);
                bufferSource.start();
                
                // Store reference for cleanup
                musicGenerator = bufferSource;
            } catch (e) {
                console.error('Failed to generate music:', e);
                // Fallback to simple ambient sound
                createAmbientFallback();
            }
        }

        function createAmbientFallback() {
            const scriptNode = audioContext.createScriptProcessor(512, 0, 2);
            let phase = 0;
            
            scriptNode.onaudioprocess = (e) => {
                const left = e.outputBuffer.getChannelData(0);
                const right = e.outputBuffer.getChannelData(1);
                
                for (let i = 0; i < left.length; i++) {
                    const noise = (Math.random() - 0.5) * 0.02;
                    const filtered = noise * (0.3 + 0.1 * Math.sin(phase * 0.001));
                    
                    left[i] = filtered;
                    right[i] = filtered * 0.8;
                    
                    phase++;
                }
            };
            
            scriptNode.connect(masterGain);
            musicGenerator = scriptNode;
        }

        // Generate song using Sonant-X
        async function generateSong(song, sampleRate) {
            const songLenSeconds = song.songLen;
            const audioCtx = new OfflineAudioContext(2, songLenSeconds * sampleRate, sampleRate);
            
            const soundGen = new MusicGenerator(audioCtx, song);
            soundGen.connect(audioCtx.destination);
            soundGen.start();
            
            const buf = await audioCtx.startRendering();
            return buf;
        }

        class MusicGenerator {
            constructor(audioCtx, song) {
                this.audioCtx = audioCtx;
                this.song = song;
                
                const mixer = this.audioCtx.createGain();
                mixer.gain.value = 1;
                
                this.tracks = [];
                
                this.song.songData.forEach((el) => {
                    const track = new TrackGenerator(this.audioCtx, el, this.bpm, this.song.endPattern);
                    track.connect(mixer);
                    this.tracks.push(track);
                });
                
                this.chain = [this.tracks, mixer];
            }
            
            get bpm() {
                return Math.round((60 * 44100 / 4) / this.song.rowLen);
            }
            
            start(when) {
                when = when || this.audioCtx.currentTime;
                this.tracks.forEach((t) => t.start(when));
            }
            
            stop(when) {
                when = when || this.audioCtx.currentTime;
                this.tracks.forEach((t) => t.stop(when));
                this.chain[this.chain.length - 1].disconnect();
            }
            
            connect(target) {
                this.chain[this.chain.length - 1].connect(target);
            }
        }

        class TrackGenerator {
            constructor(audioCtx, instr, bpm, endPattern) {
                bpm = bpm || 118;
                endPattern = endPattern || instr.p.length - 1;
                this.audioCtx = audioCtx;
                this.instr = instr;
                this.bpm = bpm;
                this.endPattern = endPattern;

                const source = this.audioCtx.createOscillator();
                const nullGain = this.audioCtx.createGain();
                nullGain.gain.value = 0;
                source.connect(nullGain);

                const scriptNode = this.audioCtx.createScriptProcessor(512, 2, 2);
                nullGain.connect(scriptNode);
                let currentSample = 0;
                let nextNote = 0;
                let sounds = [];
                
                scriptNode.onaudioprocess = (audioProcessingEvent) => {
                    const inputData = audioProcessingEvent.inputBuffer;
                    const outputData = audioProcessingEvent.outputBuffer;
                    const lchan = outputData.getChannelData(0);
                    const rchan = outputData.getChannelData(1);
                    lchan.set(inputData.getChannelData(0));
                    rchan.set(inputData.getChannelData(1));

                    sounds.slice().forEach((el) => {
                        const finished = el.write(lchan, rchan, 0);
                        if (finished) {
                            sounds = sounds.filter((el2) => {
                                return el2 !== el;
                            });
                        }
                    });

                    let nextNoteSample = nextNote * effectiveRowLen(this.audioCtx, this.bpm);
                    while (nextNoteSample >= currentSample &&
                          nextNoteSample < currentSample + inputData.length) {
                        const pattern = instr.p[Math.floor(nextNote / 32) % (this.endPattern + 1)] || 0;
                        const note = pattern === 0 ? 0 : (instr.c[pattern - 1] || { n: [] }).n[nextNote % 32] || 0;
                        if (note !== 0) {
                            const sw = new SoundWriter(this.audioCtx, instr, note, this.bpm);
                            sw.write(lchan, rchan, nextNoteSample - currentSample);
                            sounds.push(sw);
                        }
                        nextNote += 1;
                        nextNoteSample = nextNote * effectiveRowLen(this.audioCtx, this.bpm);
                    }

                    currentSample += inputData.length;
                };

                const delayTime = instr.fx_delay_time * ((1 / (this.bpm / 60)) / 8);
                const delayAmount = instr.fx_delay_amt / 255;

                const delayGain = this.audioCtx.createGain();
                delayGain.gain.value = delayAmount;
                scriptNode.connect(delayGain);

                const delay = this.audioCtx.createDelay();
                delay.delayTime.value = delayTime;
                delayGain.connect(delay);
                delay.connect(delayGain);

                const mixer = this.audioCtx.createGain();
                mixer.gain.value = 1;
                scriptNode.connect(mixer);
                delay.connect(mixer);

                this.chain = [source, nullGain, scriptNode, delayGain, delay, mixer];
            }

            start(when) {
                this.chain[0].start(when);
            }

            stop(when) {
                this.chain[0].stop(when);
                this.chain[this.chain.length - 1].disconnect();
            }

            connect(target) {
                this.chain[this.chain.length - 1].connect(target);
            }
        }

        function playTone(freq, dur, type) {
            if (!audioContext) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(masterGain || audioContext.destination);
            osc.frequency.value = freq;
            osc.type = type;
            gain.gain.setValueAtTime(0.1, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + dur);
            osc.start();
            osc.stop(audioContext.currentTime + dur);
        }
        
        function initializeGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Generate Keypad
            const keypad = document.getElementById('keypadArea');
            for (let i = 1; i <= 9; i++) {
                const btn = document.createElement('button');
                btn.className = 'keypad-btn';
                btn.textContent = i;
                btn.id = `key-${i}`;
                btn.onclick = () => handleMove(i);
                keypad.appendChild(btn);
            }

            // Resize canvas to fit container
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            window.addEventListener('resize', () => {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            });

            // Start with the first narrative scene
            showNarrativeScreen(level);
        }
        
        // === EVENT LISTENERS ===
        document.addEventListener('keydown', (e) => {
            if (e.key >= '1' && e.key <= '9') {
                handleMove(parseInt(e.key));
            } else if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });
        
        // One-time interaction to unlock audio
        document.body.addEventListener('click', initAudio, { once: true });
        document.body.addEventListener('keydown', initAudio, { once: true });

        // === START GAME ===
        initializeGame();

    </script>
</body>
</html>
